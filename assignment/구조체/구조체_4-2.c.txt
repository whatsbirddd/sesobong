7
5321 160123 2017-09-03 07:00 2017-09-03 15:12
1234 151237 2017-09-03 08:00 2017-09-03 13:42
8623 158762 2017-09-03 06:00 2017-09-03 23:59
9752 171893 2017-09-03 13:55 2017-09-03 15:22
5715 151237 2017-09-03 15:43 2017-09-03 17:31
7473 160123 2017-09-03 16:41 2017-09-03 19:00
6309 174099 2017-09-03 15:33 2017-09-03 16:12
3
6309
5715
8623



#pragma warning(disable:4996)
#include<stdio.h> 
#include<string.h>

struct car {//오제이는 나쁜놈...그럼그렇지...100점을 줄리가 없지...
	int carnum;
	int num;
	int year[2], month[2], day[2], hour[2], min[2];

};

int main() {
	struct car badcar[100];
	int numnum[100], newnum[100];
	int final[100];
	int n, tmp, count = 0;
	int i,ii, j = 0, cnt = 0, ncnt = 0,k=0;
	int paynum, paycarnum[100];
	int hour, min, pay = 0;

	scanf("%d", &n);
	for (i = 0; i < n; i++) {
		scanf("%d %d", &badcar[i].carnum, &badcar[i].num);
		scanf(" %d-%d-%d %d:%d", &badcar[i].year[0], &badcar[i].month[0], &badcar[i].day[0], &badcar[i].hour[0], &badcar[i].min[0]);
		scanf(" %d-%d-%d %d:%d", &badcar[i].year[1], &badcar[i].month[1], &badcar[i].day[1], &badcar[i].hour[1], &badcar[i].min[1]);
	}


	for (i = 0; i < n; i++) {
		j = 0;
		while (badcar[i].num != badcar[j].num) {
			j++;

		}
		if (j == i) {
			numnum[cnt] = badcar[i].num;
			cnt++;
		}

	}

	for (i = 0; i < cnt; i++) {
		count = 0;
		for (j = 0; j < n; j++) {
			if (numnum[i] == badcar[j].num) {
				count++;
			}
		}
		if (count > 1) {
			newnum[ncnt] = numnum[i];
			ncnt++;
		}
	}
	
	for (i = 0; i < ncnt; i++) {
		for (j = 0; j < n; j++) {
			if (newnum[i] == badcar[j].num) {
				final[k] = badcar[j].carnum;
				k++;
			}
		}
	}
	
	scanf("%d", &paynum);
	for (i = 0; i < paynum; i++) {
		scanf("%d", &paycarnum[i]);
	}
	for (i = 0; i < paynum; i++) {
		hour = 0;
		min = 0;
		pay = 0;
		for (j = 0; j < n; j++) {
			if (paycarnum[i] == badcar[j].carnum) {

				hour = ((badcar[j].hour[1]*60+ badcar[j].min[1]) - (badcar[j].hour[0]*60+ badcar[j].min[0]))/60;
				min = ((badcar[j].hour[1] * 60 + badcar[j].min[1]) - (badcar[j].hour[0] * 60 + badcar[j].min[0]) )% 60;

				pay += 3000;
				if (hour >0) {
					pay +=  ((hour - 1) * 60) / 10 * 1000;
					pay += (min / 10) * 1000;
					if (min % 10 != 0) {
						pay += 1000;
					}
				}
				
				if (pay > 30000) {
					pay = 30000;
				}
				for (ii = 0; ii < k; ii++) {
					if (final[ii]==paycarnum[i]) {
						pay = 100000;
					}
				}
				printf("%d\n", pay);
			}
			
		}
	}

}
====================================================
#pragma warning(disable:4996)
#include<stdio.h> 
#include<string.h>

struct car {//구조체 선언
	int carnum;
	int num;
	int year[2], month[2], day[2], hour[2], min[2];

};

int main() {
	struct car badcar[100];// 최소 100번반복
	int numnum[100], newnum[100];//새롭게 정렬한 수를 받는 배열들
	int final[100];
	int n, tmp, count = 0;
	int i, ii, j = 0, cnt = 0, ncnt = 0, k = 0;
	int paynum, paycarnum[100];
	int hour, min, pay = 0;

	scanf("%d", &n);//차 갯수 입력받기
	for (i = 0; i < n; i++) {
		scanf("%d %d", &badcar[i].carnum, &badcar[i].num);//차번호랑, 학번 입력
		scanf(" %d-%d-%d %d:%d", &badcar[i].year[0], &badcar[i].month[0], &badcar[i].day[0], &badcar[i].hour[0], &badcar[i].min[0]);//입차시간
		scanf(" %d-%d-%d %d:%d", &badcar[i].year[1], &badcar[i].month[1], &badcar[i].day[1], &badcar[i].hour[1], &badcar[i].min[1]);//출차시간
	}


	for (i = 0; i < n; i++) {//배열내에서 중복된 수를 제외한 배열을 만들기 위한
		j = 0;
		while (badcar[i].num != badcar[j].num) {//같지 않을때까지 반복
			j++;

		}
		if (j == i) {//같다면
			numnum[cnt] = badcar[i].num;//새로운 배열에 집어넣기
			cnt++;//배열 크기를 위해서 갯수 세주기
		}

	}

	for (i = 0; i < cnt; i++) {//처음에 입력받은 배열에서 중복된수를 골라내기 위한 것
		count = 0;
		for (j = 0; j < n; j++) {
			if (numnum[i] == badcar[j].num) {//만약 같다면
				count++;//갯수 세주기
			}
		}
		if (count > 1) {//1보다 크다면
			newnum[ncnt] = numnum[i];//새로운 배열에 넣어주기
			ncnt++;//새로운 배열의 크기를 측정하기 위해서 
		}
	}

	for (i = 0; i < ncnt; i++) {
		for (j = 0; j < n; j++) {
			if (newnum[i] == badcar[j].num) {//만약 같다면
				final[k] = badcar[j].carnum;//final 배열에 차번호를 넣어주기(여기서는 부정 사용자의 차 번호를 다 넣어줘야한다.)
				k++;//final 배열의 크기를 위해 
			}
		}
	}

	scanf("%d", &paynum);//몇명의 차량번호를 확인할 것인지 입력받기
	for (i = 0; i < paynum; i++) {
		scanf("%d", &paycarnum[i]);//차 번호 입력
	}
	for (i = 0; i < paynum; i++) {
		hour = 0;//hour초기화
		min = 0;//min초기화
		pay = 0;//pay 초기화
		for (j = 0; j < n; j++) {
			if (paycarnum[i] == badcar[j].carnum) {//입력받은 차량번호와 맨처음에 입력받은 차량번호가 같을때

				hour = ((badcar[j].hour[1] * 60 + badcar[j].min[1]) - (badcar[j].hour[0] * 60 + badcar[j].min[0])) / 60;//시간 계산
				min = ((badcar[j].hour[1] * 60 + badcar[j].min[1]) - (badcar[j].hour[0] * 60 + badcar[j].min[0])) % 60;////분계산

				pay += 3000;//일단 pay에 3000원 더해주기(처음1시간은 무조건 3000원이다.)
				if (hour > 0) {//시간이 0보다 크다면
					pay += ((hour - 1) * 60) / 10 * 1000;//시간에서 1뺀 후에 10분에 1000원씩 계산해주기
					pay += (min / 10) * 1000;//그리고 분만큼 또 10분에 천원씩 계산해주기
					if (min % 10 != 0) {//그리고 예를 들어 31분일 경우 3000원이 아니라 4000원으로 계산해주기 위해
						pay += 1000;//min을 10으로 나누었을때 나머지가 0이 아니라면 pay에 1000원 더해주기
					}
				}

				if (pay > 30000) {//30000원 넘어가면 
					pay = 30000;//걍 30000원으로 깎아드림
				}
				for (ii = 0; ii < k; ii++) {//부정 사용자 찾기
					if (final[ii] == paycarnum[i]) {
						pay = 100000;//벌금 10만원이유
					}
				}
				printf("%d\n", pay);//pay출력
			}

		}
	}

}

#pragma warning(disable:4996)
#include<stdio.h> 
#include<string.h>

struct car {//구조체 선언
	int carnum;
	int num;
	int year[2], month[2], day[2], hour[2], min[2];

};

int main() {
	struct car badcar[100];// 최소 100번반복
	int numnum[100], newnum[100];//새롭게 정렬한 수를 받는 배열들
	int final[100];
	int n, tmp, count = 0;
	int i, ii, j = 0, cnt = 0, ncnt = 0, k = 0;
	int paynum, paycarnum[100];
	int hour, min, pay = 0;

	scanf("%d", &n);//차 갯수 입력받기
	for (i = 0; i < n; i++) {
		scanf("%d %d", &badcar[i].carnum, &badcar[i].num);//차번호랑, 학번 입력
		scanf(" %d-%d-%d %d:%d", &badcar[i].year[0], &badcar[i].month[0], &badcar[i].day[0], &badcar[i].hour[0], &badcar[i].min[0]);//입차시간
		scanf(" %d-%d-%d %d:%d", &badcar[i].year[1], &badcar[i].month[1], &badcar[i].day[1], &badcar[i].hour[1], &badcar[i].min[1]);//출차시간
	}


	for (i = 0; i < n; i++) {//배열내에서 중복된 수를 제외한 배열을 만들기 위한
		j = 0;
		while (badcar[i].num != badcar[j].num) {//같지 않을때까지 반복
			j++;

		}
		if (j == i) {//같다면
			numnum[cnt] = badcar[i].num;//새로운 배열에 집어넣기
			cnt++;//배열 크기를 위해서 갯수 세주기
		}

	}

	for (i = 0; i < cnt; i++) {//처음에 입력받은 배열에서 중복된수를 골라내기 위한 것
		count = 0;
		for (j = 0; j < n; j++) {
			if (numnum[i] == badcar[j].num) {//만약 같다면
				count++;//갯수 세주기
			}
		}
		if (count > 1) {//1보다 크다면
			newnum[ncnt] = numnum[i];//새로운 배열에 넣어주기
			ncnt++;//새로운 배열의 크기를 측정하기 위해서 
		}
	}

	for (i = 0; i < ncnt; i++) {
		for (j = 0; j < n; j++) {
			if (newnum[i] == badcar[j].num) {//만약 같다면
				final[k] = badcar[j].carnum;//final 배열에 차번호를 넣어주기(여기서는 부정 사용자의 차 번호를 다 넣어줘야한다.)
				k++;//final 배열의 크기를 위해 
			}
		}
	}

	scanf("%d", &paynum);//몇명의 차량번호를 확인할 것인지 입력받기
	for (i = 0; i < paynum; i++) {
		scanf("%d", &paycarnum[i]);//차 번호 입력
	}
	for (i = 0; i < paynum; i++) {
		hour = 0;//hour초기화
		min = 0;//min초기화
		pay = 0;//pay 초기화
		for (j = 0; j < n; j++) {
			if (paycarnum[i] == badcar[j].carnum) {//입력받은 차량번호와 맨처음에 입력받은 차량번호가 같을때

				hour = ((badcar[j].hour[1] * 60 + badcar[j].min[1]) - (badcar[j].hour[0] * 60 + badcar[j].min[0])) / 60;//시간 계산
				min = ((badcar[j].hour[1] * 60 + badcar[j].min[1]) - (badcar[j].hour[0] * 60 + badcar[j].min[0])) % 60;////분계산

				pay += 3000;//일단 pay에 3000원 더해주기(처음1시간은 무조건 3000원이다.)
				if (hour > 0) {//시간이 0보다 크다면
					pay += ((hour - 1) * 60) / 10 * 1000;//시간에서 1뺀 후에 10분에 1000원씩 계산해주기
					pay += (min / 10) * 1000;//그리고 분만큼 또 10분에 천원씩 계산해주기
					if (min % 10 != 0) {//그리고 예를 들어 31분일 경우 3000원이 아니라 4000원으로 계산해주기 위해
						pay += 1000;//min을 10으로 나누었을때 나머지가 0이 아니라면 pay에 1000원 더해주기
					}
				}

				if (pay > 30000) {//30000원 넘어가면 
					pay = 30000;//걍 30000원으로 깎아드림
				}
				for (ii = 0; ii < k; ii++) {//부정 사용자 찾기
					if (final[ii] == paycarnum[i]) {
						pay = 100000;//벌금 10만원이유
					}
				}
				printf("%d\n", pay);//pay출력
			}

		}
	}

}
